// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium postgresclusters.postgres-operator.crunchydata.com
// kopium version: 0.14.0

use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
use kube::CustomResource;
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(
    group = "postgres-operator.crunchydata.com",
    version = "v1beta1",
    kind = "PostgresCluster",
    plural = "postgresclusters"
)]
#[kube(namespaced)]
#[kube(status = "PostgresClusterStatus")]
#[kube(schema = "disabled")]
pub struct PostgresClusterSpec {
    pub backups: PostgresClusterBackups,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<PostgresClusterConfig>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customReplicationTLSSecret"
    )]
    pub custom_replication_tls_secret: Option<PostgresClusterCustomReplicationTLSSecret>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customTLSSecret"
    )]
    pub custom_tls_secret: Option<PostgresClusterCustomTLSSecret>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSource"
    )]
    pub data_source: Option<PostgresClusterDataSource>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseInitSQL"
    )]
    pub database_init_sql: Option<PostgresClusterDatabaseInitSQL>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "disableDefaultPodScheduling"
    )]
    pub disable_default_pod_scheduling: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imagePullPolicy"
    )]
    pub image_pull_policy: Option<PostgresClusterImagePullPolicy>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imagePullSecrets"
    )]
    pub image_pull_secrets: Option<Vec<PostgresClusterImagePullSecrets>>,
    pub instances: Vec<PostgresClusterInstances>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PostgresClusterMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitoring: Option<PostgresClusterMonitoring>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub openshift: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patroni: Option<PostgresClusterPatroni>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postGISVersion"
    )]
    pub post_gis_version: Option<String>,
    #[serde(rename = "postgresVersion")]
    pub postgres_version: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<PostgresClusterProxy>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<PostgresClusterService>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shutdown: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<PostgresClusterStandby>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "supplementalGroups"
    )]
    pub supplemental_groups: Option<Vec<i64>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userInterface"
    )]
    pub user_interface: Option<PostgresClusterUserInterface>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<PostgresClusterUsers>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackups {
    pub pgbackrest: PostgresClusterBackupsPgbackrest,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<Vec<PostgresClusterBackupsPgbackrestConfiguration>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jobs: Option<PostgresClusterBackupsPgbackrestJobs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub manual: Option<PostgresClusterBackupsPgbackrestManual>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PostgresClusterBackupsPgbackrestMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoHost")]
    pub repo_host: Option<PostgresClusterBackupsPgbackrestRepoHost>,
    pub repos: Vec<PostgresClusterBackupsPgbackrestRepos>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restore: Option<PostgresClusterBackupsPgbackrestRestore>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<PostgresClusterBackupsPgbackrestSidecars>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PostgresClusterBackupsPgbackrestConfigurationConfigMap>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "downwardAPI"
    )]
    pub downward_api: Option<PostgresClusterBackupsPgbackrestConfigurationDownwardAPI>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PostgresClusterBackupsPgbackrestConfigurationSecret>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountToken"
    )]
    pub service_account_token:
        Option<PostgresClusterBackupsPgbackrestConfigurationServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterBackupsPgbackrestConfigurationConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationDownwardAPI {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterBackupsPgbackrestConfigurationDownwardAPIItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationDownwardAPIItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<PostgresClusterBackupsPgbackrestConfigurationDownwardAPIItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref:
        Option<PostgresClusterBackupsPgbackrestConfigurationDownwardAPIItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationDownwardAPIItemsFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationDownwardAPIItemsResourceFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterBackupsPgbackrestConfigurationSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestConfigurationServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expirationSeconds"
    )]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PostgresClusterBackupsPgbackrestJobsAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterBackupsPgbackrestJobsResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresClusterBackupsPgbackrestJobsTolerations>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ttlSecondsAfterFinished"
    )]
    pub ttl_seconds_after_finished: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinity {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeAffinity"
    )]
    pub node_affinity: Option<PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAffinity"
    )]
    pub pod_affinity: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAntiAffinity"
    )]
    pub pod_anti_affinity: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestJobsTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tolerationSeconds"
    )]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestManual {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    #[serde(rename = "repoName")]
    pub repo_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHost {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PostgresClusterBackupsPgbackrestRepoHostAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterBackupsPgbackrestRepoHostResources>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sshConfigMap"
    )]
    pub ssh_config_map: Option<PostgresClusterBackupsPgbackrestRepoHostSshConfigMap>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sshSecret")]
    pub ssh_secret: Option<PostgresClusterBackupsPgbackrestRepoHostSshSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostTolerations>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "topologySpreadConstraints"
    )]
    pub topology_spread_constraints:
        Option<Vec<PostgresClusterBackupsPgbackrestRepoHostTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinity {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeAffinity"
    )]
    pub node_affinity: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAffinity"
    )]
    pub pod_affinity: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAntiAffinity"
    )]
    pub pod_anti_affinity: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostSshConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostSshConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostSshConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostSshSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostSshSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostSshSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tolerationSeconds"
    )]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostTopologySpreadConstraints {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "labelSelector"
    )]
    pub label_selector:
        Option<PostgresClusterBackupsPgbackrestRepoHostTopologySpreadConstraintsLabelSelector>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minDomains"
    )]
    pub min_domains: Option<i32>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostTopologySpreadConstraintsLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRepoHostTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepoHostTopologySpreadConstraintsLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRepos {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub azure: Option<PostgresClusterBackupsPgbackrestReposAzure>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcs: Option<PostgresClusterBackupsPgbackrestReposGcs>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<PostgresClusterBackupsPgbackrestReposS3>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedules: Option<PostgresClusterBackupsPgbackrestReposSchedules>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volume: Option<PostgresClusterBackupsPgbackrestReposVolume>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposAzure {
    pub container: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposGcs {
    pub bucket: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposS3 {
    pub bucket: String,
    pub endpoint: String,
    pub region: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposSchedules {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub differential: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub incremental: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposVolume {
    #[serde(rename = "volumeClaimSpec")]
    pub volume_claim_spec: PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpec,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpec {
    #[serde(rename = "accessModes")]
    pub access_modes: Vec<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSource"
    )]
    pub data_source: Option<PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecDataSource>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSourceRef"
    )]
    pub data_source_ref:
        Option<PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecDataSourceRef>,
    pub resources: PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecResources,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecSelector>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClassName"
    )]
    pub storage_class_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeMode"
    )]
    pub volume_mode: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeName"
    )]
    pub volume_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecDataSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecDataSourceRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    pub requests: BTreeMap<String, IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecSelector {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchExpressions"
    )]
    pub match_expressions: Option<
        Vec<PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecSelectorMatchExpressions>,
    >,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestReposVolumeVolumeClaimSpecSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestore {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PostgresClusterBackupsPgbackrestRestoreAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterName"
    )]
    pub cluster_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterNamespace"
    )]
    pub cluster_namespace: Option<String>,
    pub enabled: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    #[serde(rename = "repoName")]
    pub repo_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterBackupsPgbackrestRestoreResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresClusterBackupsPgbackrestRestoreTolerations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinity {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeAffinity"
    )]
    pub node_affinity: Option<PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAffinity"
    )]
    pub pod_affinity: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAntiAffinity"
    )]
    pub pod_anti_affinity: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestRestoreTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tolerationSeconds"
    )]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestSidecars {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pgbackrest: Option<PostgresClusterBackupsPgbackrestSidecarsPgbackrest>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pgbackrestConfig"
    )]
    pub pgbackrest_config: Option<PostgresClusterBackupsPgbackrestSidecarsPgbackrestConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestSidecarsPgbackrest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterBackupsPgbackrestSidecarsPgbackrestResources>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestSidecarsPgbackrestResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestSidecarsPgbackrestConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterBackupsPgbackrestSidecarsPgbackrestConfigResources>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterBackupsPgbackrestSidecarsPgbackrestConfigResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<PostgresClusterConfigFiles>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFiles {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PostgresClusterConfigFilesConfigMap>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "downwardAPI"
    )]
    pub downward_api: Option<PostgresClusterConfigFilesDownwardAPI>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PostgresClusterConfigFilesSecret>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountToken"
    )]
    pub service_account_token: Option<PostgresClusterConfigFilesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterConfigFilesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesDownwardAPI {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterConfigFilesDownwardAPIItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesDownwardAPIItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<PostgresClusterConfigFilesDownwardAPIItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref: Option<PostgresClusterConfigFilesDownwardAPIItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesDownwardAPIItemsFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesDownwardAPIItemsResourceFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterConfigFilesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterConfigFilesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expirationSeconds"
    )]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterCustomReplicationTLSSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterCustomReplicationTLSSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterCustomReplicationTLSSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterCustomTLSSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterCustomTLSSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterCustomTLSSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSource {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pgbackrest: Option<PostgresClusterDataSourcePgbackrest>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postgresCluster"
    )]
    pub postgres_cluster: Option<PostgresClusterDataSourcePostgresCluster>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volumes: Option<PostgresClusterDataSourceVolumes>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PostgresClusterDataSourcePgbackrestAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<Vec<PostgresClusterDataSourcePgbackrestConfiguration>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    pub repo: PostgresClusterDataSourcePgbackrestRepo,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterDataSourcePgbackrestResources>,
    pub stanza: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresClusterDataSourcePgbackrestTolerations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinity {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeAffinity"
    )]
    pub node_affinity: Option<PostgresClusterDataSourcePgbackrestAffinityNodeAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAffinity"
    )]
    pub pod_affinity: Option<PostgresClusterDataSourcePgbackrestAffinityPodAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAntiAffinity"
    )]
    pub pod_anti_affinity: Option<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresClusterDataSourcePgbackrestAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresClusterDataSourcePgbackrestAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresClusterDataSourcePgbackrestAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PostgresClusterDataSourcePgbackrestConfigurationConfigMap>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "downwardAPI"
    )]
    pub downward_api: Option<PostgresClusterDataSourcePgbackrestConfigurationDownwardAPI>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PostgresClusterDataSourcePgbackrestConfigurationSecret>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountToken"
    )]
    pub service_account_token:
        Option<PostgresClusterDataSourcePgbackrestConfigurationServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterDataSourcePgbackrestConfigurationConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationDownwardAPI {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterDataSourcePgbackrestConfigurationDownwardAPIItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationDownwardAPIItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<PostgresClusterDataSourcePgbackrestConfigurationDownwardAPIItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref:
        Option<PostgresClusterDataSourcePgbackrestConfigurationDownwardAPIItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationDownwardAPIItemsFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationDownwardAPIItemsResourceFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterDataSourcePgbackrestConfigurationSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestConfigurationServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expirationSeconds"
    )]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepo {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub azure: Option<PostgresClusterDataSourcePgbackrestRepoAzure>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcs: Option<PostgresClusterDataSourcePgbackrestRepoGcs>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<PostgresClusterDataSourcePgbackrestRepoS3>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedules: Option<PostgresClusterDataSourcePgbackrestRepoSchedules>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volume: Option<PostgresClusterDataSourcePgbackrestRepoVolume>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoAzure {
    pub container: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoGcs {
    pub bucket: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoS3 {
    pub bucket: String,
    pub endpoint: String,
    pub region: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoSchedules {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub differential: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub full: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub incremental: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoVolume {
    #[serde(rename = "volumeClaimSpec")]
    pub volume_claim_spec: PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpec,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpec {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessModes"
    )]
    pub access_modes: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSource"
    )]
    pub data_source: Option<PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecDataSource>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSourceRef"
    )]
    pub data_source_ref:
        Option<PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecDataSourceRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecSelector>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClassName"
    )]
    pub storage_class_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeMode"
    )]
    pub volume_mode: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeName"
    )]
    pub volume_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecDataSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecDataSourceRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecSelector {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchExpressions"
    )]
    pub match_expressions: Option<
        Vec<PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecSelectorMatchExpressions>,
    >,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestRepoVolumeVolumeClaimSpecSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePgbackrestTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tolerationSeconds"
    )]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresCluster {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PostgresClusterDataSourcePostgresClusterAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterName"
    )]
    pub cluster_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clusterNamespace"
    )]
    pub cluster_namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    #[serde(rename = "repoName")]
    pub repo_name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterDataSourcePostgresClusterResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresClusterDataSourcePostgresClusterTolerations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinity {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeAffinity"
    )]
    pub node_affinity: Option<PostgresClusterDataSourcePostgresClusterAffinityNodeAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAffinity"
    )]
    pub pod_affinity: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAntiAffinity"
    )]
    pub pod_anti_affinity: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourcePostgresClusterTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tolerationSeconds"
    )]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourceVolumes {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pgBackRestVolume"
    )]
    pub pg_back_rest_volume: Option<PostgresClusterDataSourceVolumesPgBackRestVolume>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pgDataVolume"
    )]
    pub pg_data_volume: Option<PostgresClusterDataSourceVolumesPgDataVolume>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pgWALVolume"
    )]
    pub pg_wal_volume: Option<PostgresClusterDataSourceVolumesPgWALVolume>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourceVolumesPgBackRestVolume {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    #[serde(rename = "pvcName")]
    pub pvc_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourceVolumesPgDataVolume {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    #[serde(rename = "pvcName")]
    pub pvc_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDataSourceVolumesPgWALVolume {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
    #[serde(rename = "pvcName")]
    pub pvc_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterDatabaseInitSQL {
    pub key: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresClusterImagePullPolicy {
    Always,
    Never,
    IfNotPresent,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterImagePullSecrets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstances {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PostgresClusterInstancesAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<Vec<PostgresClusterInstancesContainers>>,
    #[serde(rename = "dataVolumeClaimSpec")]
    pub data_volume_claim_spec: PostgresClusterInstancesDataVolumeClaimSpec,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PostgresClusterInstancesMetadata>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minAvailable"
    )]
    pub min_available: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterInstancesResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<PostgresClusterInstancesSidecars>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresClusterInstancesTolerations>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "topologySpreadConstraints"
    )]
    pub topology_spread_constraints: Option<Vec<PostgresClusterInstancesTopologySpreadConstraints>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "walVolumeClaimSpec"
    )]
    pub wal_volume_claim_spec: Option<PostgresClusterInstancesWalVolumeClaimSpec>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinity {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeAffinity"
    )]
    pub node_affinity: Option<PostgresClusterInstancesAffinityNodeAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAffinity"
    )]
    pub pod_affinity: Option<PostgresClusterInstancesAffinityPodAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAntiAffinity"
    )]
    pub pod_anti_affinity: Option<PostgresClusterInstancesAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterInstancesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresClusterInstancesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresClusterInstancesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterInstancesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresClusterInstancesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterInstancesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<PostgresClusterInstancesContainersEnv>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<PostgresClusterInstancesContainersEnvFrom>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imagePullPolicy"
    )]
    pub image_pull_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<PostgresClusterInstancesContainersLifecycle>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "livenessProbe"
    )]
    pub liveness_probe: Option<PostgresClusterInstancesContainersLivenessProbe>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<PostgresClusterInstancesContainersPorts>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readinessProbe"
    )]
    pub readiness_probe: Option<PostgresClusterInstancesContainersReadinessProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterInstancesContainersResources>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityContext"
    )]
    pub security_context: Option<PostgresClusterInstancesContainersSecurityContext>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "startupProbe"
    )]
    pub startup_probe: Option<PostgresClusterInstancesContainersStartupProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationMessagePath"
    )]
    pub termination_message_path: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationMessagePolicy"
    )]
    pub termination_message_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeDevices"
    )]
    pub volume_devices: Option<Vec<PostgresClusterInstancesContainersVolumeDevices>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeMounts"
    )]
    pub volume_mounts: Option<Vec<PostgresClusterInstancesContainersVolumeMounts>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workingDir"
    )]
    pub working_dir: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnv {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<PostgresClusterInstancesContainersEnvValueFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnvValueFrom {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configMapKeyRef"
    )]
    pub config_map_key_ref: Option<PostgresClusterInstancesContainersEnvValueFromConfigMapKeyRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<PostgresClusterInstancesContainersEnvValueFromFieldRef>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref: Option<PostgresClusterInstancesContainersEnvValueFromResourceFieldRef>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretKeyRef"
    )]
    pub secret_key_ref: Option<PostgresClusterInstancesContainersEnvValueFromSecretKeyRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnvValueFromConfigMapKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnvValueFromFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnvValueFromResourceFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnvValueFromSecretKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnvFrom {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configMapRef"
    )]
    pub config_map_ref: Option<PostgresClusterInstancesContainersEnvFromConfigMapRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<PostgresClusterInstancesContainersEnvFromSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnvFromConfigMapRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersEnvFromSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecycle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<PostgresClusterInstancesContainersLifecyclePostStart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<PostgresClusterInstancesContainersLifecyclePreStop>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePostStart {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterInstancesContainersLifecyclePostStartExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterInstancesContainersLifecyclePostStartHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterInstancesContainersLifecyclePostStartTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePostStartExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePostStartHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterInstancesContainersLifecyclePostStartHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePostStartHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePostStartTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePreStop {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterInstancesContainersLifecyclePreStopExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterInstancesContainersLifecyclePreStopHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterInstancesContainersLifecyclePreStopTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePreStopExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePreStopHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterInstancesContainersLifecyclePreStopHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePreStopHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLifecyclePreStopTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLivenessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterInstancesContainersLivenessProbeExec>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "failureThreshold"
    )]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<PostgresClusterInstancesContainersLivenessProbeGrpc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterInstancesContainersLivenessProbeHttpGet>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initialDelaySeconds"
    )]
    pub initial_delay_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "periodSeconds"
    )]
    pub period_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "successThreshold"
    )]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterInstancesContainersLivenessProbeTcpSocket>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationGracePeriodSeconds"
    )]
    pub termination_grace_period_seconds: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutSeconds"
    )]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLivenessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLivenessProbeGrpc {
    pub port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLivenessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterInstancesContainersLivenessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLivenessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersLivenessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersPorts {
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersReadinessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterInstancesContainersReadinessProbeExec>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "failureThreshold"
    )]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<PostgresClusterInstancesContainersReadinessProbeGrpc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterInstancesContainersReadinessProbeHttpGet>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initialDelaySeconds"
    )]
    pub initial_delay_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "periodSeconds"
    )]
    pub period_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "successThreshold"
    )]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterInstancesContainersReadinessProbeTcpSocket>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationGracePeriodSeconds"
    )]
    pub termination_grace_period_seconds: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutSeconds"
    )]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersReadinessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersReadinessProbeGrpc {
    pub port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersReadinessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterInstancesContainersReadinessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersReadinessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersReadinessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersSecurityContext {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowPrivilegeEscalation"
    )]
    pub allow_privilege_escalation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<PostgresClusterInstancesContainersSecurityContextCapabilities>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readOnlyRootFilesystem"
    )]
    pub read_only_root_filesystem: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runAsGroup"
    )]
    pub run_as_group: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runAsNonRoot"
    )]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "seLinuxOptions"
    )]
    pub se_linux_options: Option<PostgresClusterInstancesContainersSecurityContextSeLinuxOptions>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "seccompProfile"
    )]
    pub seccomp_profile: Option<PostgresClusterInstancesContainersSecurityContextSeccompProfile>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "windowsOptions"
    )]
    pub windows_options: Option<PostgresClusterInstancesContainersSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersSecurityContextCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersSecurityContextSeccompProfile {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localhostProfile"
    )]
    pub localhost_profile: Option<String>,
    #[serde(rename = "type")]
    pub r#type: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersSecurityContextWindowsOptions {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gmsaCredentialSpec"
    )]
    pub gmsa_credential_spec: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gmsaCredentialSpecName"
    )]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostProcess"
    )]
    pub host_process: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runAsUserName"
    )]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersStartupProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterInstancesContainersStartupProbeExec>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "failureThreshold"
    )]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<PostgresClusterInstancesContainersStartupProbeGrpc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterInstancesContainersStartupProbeHttpGet>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initialDelaySeconds"
    )]
    pub initial_delay_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "periodSeconds"
    )]
    pub period_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "successThreshold"
    )]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterInstancesContainersStartupProbeTcpSocket>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationGracePeriodSeconds"
    )]
    pub termination_grace_period_seconds: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutSeconds"
    )]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersStartupProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersStartupProbeGrpc {
    pub port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersStartupProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers: Option<Vec<PostgresClusterInstancesContainersStartupProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersStartupProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersStartupProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersVolumeDevices {
    #[serde(rename = "devicePath")]
    pub device_path: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesContainersVolumeMounts {
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mountPropagation"
    )]
    pub mount_propagation: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subPathExpr"
    )]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesDataVolumeClaimSpec {
    #[serde(rename = "accessModes")]
    pub access_modes: Vec<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSource"
    )]
    pub data_source: Option<PostgresClusterInstancesDataVolumeClaimSpecDataSource>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSourceRef"
    )]
    pub data_source_ref: Option<PostgresClusterInstancesDataVolumeClaimSpecDataSourceRef>,
    pub resources: PostgresClusterInstancesDataVolumeClaimSpecResources,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresClusterInstancesDataVolumeClaimSpecSelector>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClassName"
    )]
    pub storage_class_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeMode"
    )]
    pub volume_mode: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeName"
    )]
    pub volume_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesDataVolumeClaimSpecDataSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesDataVolumeClaimSpecDataSourceRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesDataVolumeClaimSpecResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    pub requests: BTreeMap<String, IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesDataVolumeClaimSpecSelector {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchExpressions"
    )]
    pub match_expressions:
        Option<Vec<PostgresClusterInstancesDataVolumeClaimSpecSelectorMatchExpressions>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesDataVolumeClaimSpecSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesSidecars {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicaCertCopy"
    )]
    pub replica_cert_copy: Option<PostgresClusterInstancesSidecarsReplicaCertCopy>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesSidecarsReplicaCertCopy {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterInstancesSidecarsReplicaCertCopyResources>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesSidecarsReplicaCertCopyResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tolerationSeconds"
    )]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesTopologySpreadConstraints {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "labelSelector"
    )]
    pub label_selector: Option<PostgresClusterInstancesTopologySpreadConstraintsLabelSelector>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minDomains"
    )]
    pub min_domains: Option<i32>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesTopologySpreadConstraintsLabelSelector {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchExpressions"
    )]
    pub match_expressions:
        Option<Vec<PostgresClusterInstancesTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesTopologySpreadConstraintsLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesWalVolumeClaimSpec {
    #[serde(rename = "accessModes")]
    pub access_modes: Vec<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSource"
    )]
    pub data_source: Option<PostgresClusterInstancesWalVolumeClaimSpecDataSource>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSourceRef"
    )]
    pub data_source_ref: Option<PostgresClusterInstancesWalVolumeClaimSpecDataSourceRef>,
    pub resources: PostgresClusterInstancesWalVolumeClaimSpecResources,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresClusterInstancesWalVolumeClaimSpecSelector>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClassName"
    )]
    pub storage_class_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeMode"
    )]
    pub volume_mode: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeName"
    )]
    pub volume_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesWalVolumeClaimSpecDataSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesWalVolumeClaimSpecDataSourceRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesWalVolumeClaimSpecResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    pub requests: BTreeMap<String, IntOrString>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesWalVolumeClaimSpecSelector {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchExpressions"
    )]
    pub match_expressions:
        Option<Vec<PostgresClusterInstancesWalVolumeClaimSpecSelectorMatchExpressions>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterInstancesWalVolumeClaimSpecSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoring {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pgmonitor: Option<PostgresClusterMonitoringPgmonitor>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitor {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exporter: Option<PostgresClusterMonitoringPgmonitorExporter>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporter {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub configuration: Option<Vec<PostgresClusterMonitoringPgmonitorExporterConfiguration>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customTLSSecret"
    )]
    pub custom_tls_secret: Option<PostgresClusterMonitoringPgmonitorExporterCustomTLSSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterMonitoringPgmonitorExporterResources>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PostgresClusterMonitoringPgmonitorExporterConfigurationConfigMap>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "downwardAPI"
    )]
    pub downward_api: Option<PostgresClusterMonitoringPgmonitorExporterConfigurationDownwardAPI>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PostgresClusterMonitoringPgmonitorExporterConfigurationSecret>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountToken"
    )]
    pub service_account_token:
        Option<PostgresClusterMonitoringPgmonitorExporterConfigurationServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterMonitoringPgmonitorExporterConfigurationConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationDownwardAPI {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterMonitoringPgmonitorExporterConfigurationDownwardAPIItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationDownwardAPIItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref:
        Option<PostgresClusterMonitoringPgmonitorExporterConfigurationDownwardAPIItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref: Option<
        PostgresClusterMonitoringPgmonitorExporterConfigurationDownwardAPIItemsResourceFieldRef,
    >,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationDownwardAPIItemsFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationDownwardAPIItemsResourceFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterMonitoringPgmonitorExporterConfigurationSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterConfigurationServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expirationSeconds"
    )]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterCustomTLSSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterMonitoringPgmonitorExporterCustomTLSSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterCustomTLSSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterMonitoringPgmonitorExporterResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterPatroni {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dynamicConfiguration"
    )]
    pub dynamic_configuration: Option<BTreeMap<String, serde_json::Value>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "leaderLeaseDurationSeconds"
    )]
    pub leader_lease_duration_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub switchover: Option<PostgresClusterPatroniSwitchover>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "syncPeriodSeconds"
    )]
    pub sync_period_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterPatroniSwitchover {
    pub enabled: bool,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetInstance"
    )]
    pub target_instance: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<PostgresClusterPatroniSwitchoverType>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresClusterPatroniSwitchoverType {
    Switchover,
    Failover,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxy {
    #[serde(rename = "pgBouncer")]
    pub pg_bouncer: PostgresClusterProxyPgBouncer,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncer {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PostgresClusterProxyPgBouncerAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<PostgresClusterProxyPgBouncerConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<Vec<PostgresClusterProxyPgBouncerContainers>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "customTLSSecret"
    )]
    pub custom_tls_secret: Option<PostgresClusterProxyPgBouncerCustomTLSSecret>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PostgresClusterProxyPgBouncerMetadata>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minAvailable"
    )]
    pub min_available: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterProxyPgBouncerResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<PostgresClusterProxyPgBouncerService>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<PostgresClusterProxyPgBouncerSidecars>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresClusterProxyPgBouncerTolerations>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "topologySpreadConstraints"
    )]
    pub topology_spread_constraints:
        Option<Vec<PostgresClusterProxyPgBouncerTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinity {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeAffinity"
    )]
    pub node_affinity: Option<PostgresClusterProxyPgBouncerAffinityNodeAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAffinity"
    )]
    pub pod_affinity: Option<PostgresClusterProxyPgBouncerAffinityPodAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAntiAffinity"
    )]
    pub pod_anti_affinity: Option<PostgresClusterProxyPgBouncerAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterProxyPgBouncerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresClusterProxyPgBouncerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresClusterProxyPgBouncerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterProxyPgBouncerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresClusterProxyPgBouncerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterProxyPgBouncerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub databases: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<PostgresClusterProxyPgBouncerConfigFiles>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub global: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFiles {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PostgresClusterProxyPgBouncerConfigFilesConfigMap>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "downwardAPI"
    )]
    pub downward_api: Option<PostgresClusterProxyPgBouncerConfigFilesDownwardAPI>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PostgresClusterProxyPgBouncerConfigFilesSecret>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountToken"
    )]
    pub service_account_token: Option<PostgresClusterProxyPgBouncerConfigFilesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterProxyPgBouncerConfigFilesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesDownwardAPI {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterProxyPgBouncerConfigFilesDownwardAPIItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesDownwardAPIItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<PostgresClusterProxyPgBouncerConfigFilesDownwardAPIItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref:
        Option<PostgresClusterProxyPgBouncerConfigFilesDownwardAPIItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesDownwardAPIItemsFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesDownwardAPIItemsResourceFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterProxyPgBouncerConfigFilesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerConfigFilesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expirationSeconds"
    )]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<PostgresClusterProxyPgBouncerContainersEnv>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "envFrom")]
    pub env_from: Option<Vec<PostgresClusterProxyPgBouncerContainersEnvFrom>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "imagePullPolicy"
    )]
    pub image_pull_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<PostgresClusterProxyPgBouncerContainersLifecycle>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "livenessProbe"
    )]
    pub liveness_probe: Option<PostgresClusterProxyPgBouncerContainersLivenessProbe>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<PostgresClusterProxyPgBouncerContainersPorts>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readinessProbe"
    )]
    pub readiness_probe: Option<PostgresClusterProxyPgBouncerContainersReadinessProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterProxyPgBouncerContainersResources>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "securityContext"
    )]
    pub security_context: Option<PostgresClusterProxyPgBouncerContainersSecurityContext>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "startupProbe"
    )]
    pub startup_probe: Option<PostgresClusterProxyPgBouncerContainersStartupProbe>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stdin: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "stdinOnce")]
    pub stdin_once: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationMessagePath"
    )]
    pub termination_message_path: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationMessagePolicy"
    )]
    pub termination_message_policy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tty: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeDevices"
    )]
    pub volume_devices: Option<Vec<PostgresClusterProxyPgBouncerContainersVolumeDevices>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeMounts"
    )]
    pub volume_mounts: Option<Vec<PostgresClusterProxyPgBouncerContainersVolumeMounts>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workingDir"
    )]
    pub working_dir: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnv {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<PostgresClusterProxyPgBouncerContainersEnvValueFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnvValueFrom {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configMapKeyRef"
    )]
    pub config_map_key_ref:
        Option<PostgresClusterProxyPgBouncerContainersEnvValueFromConfigMapKeyRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<PostgresClusterProxyPgBouncerContainersEnvValueFromFieldRef>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref:
        Option<PostgresClusterProxyPgBouncerContainersEnvValueFromResourceFieldRef>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretKeyRef"
    )]
    pub secret_key_ref: Option<PostgresClusterProxyPgBouncerContainersEnvValueFromSecretKeyRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnvValueFromConfigMapKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnvValueFromFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnvValueFromResourceFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnvValueFromSecretKeyRef {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnvFrom {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configMapRef"
    )]
    pub config_map_ref: Option<PostgresClusterProxyPgBouncerContainersEnvFromConfigMapRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<PostgresClusterProxyPgBouncerContainersEnvFromSecretRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnvFromConfigMapRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersEnvFromSecretRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecycle {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postStart")]
    pub post_start: Option<PostgresClusterProxyPgBouncerContainersLifecyclePostStart>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preStop")]
    pub pre_stop: Option<PostgresClusterProxyPgBouncerContainersLifecyclePreStop>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePostStart {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterProxyPgBouncerContainersLifecyclePostStartExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterProxyPgBouncerContainersLifecyclePostStartHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterProxyPgBouncerContainersLifecyclePostStartTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePostStartExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePostStartHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterProxyPgBouncerContainersLifecyclePostStartHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePostStartHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePostStartTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePreStop {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterProxyPgBouncerContainersLifecyclePreStopExec>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterProxyPgBouncerContainersLifecyclePreStopHttpGet>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterProxyPgBouncerContainersLifecyclePreStopTcpSocket>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePreStopExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePreStopHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterProxyPgBouncerContainersLifecyclePreStopHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePreStopHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLifecyclePreStopTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLivenessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterProxyPgBouncerContainersLivenessProbeExec>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "failureThreshold"
    )]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<PostgresClusterProxyPgBouncerContainersLivenessProbeGrpc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterProxyPgBouncerContainersLivenessProbeHttpGet>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initialDelaySeconds"
    )]
    pub initial_delay_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "periodSeconds"
    )]
    pub period_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "successThreshold"
    )]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterProxyPgBouncerContainersLivenessProbeTcpSocket>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationGracePeriodSeconds"
    )]
    pub termination_grace_period_seconds: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutSeconds"
    )]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLivenessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLivenessProbeGrpc {
    pub port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLivenessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterProxyPgBouncerContainersLivenessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLivenessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersLivenessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersPorts {
    #[serde(rename = "containerPort")]
    pub container_port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostIP")]
    pub host_ip: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hostPort")]
    pub host_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersReadinessProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterProxyPgBouncerContainersReadinessProbeExec>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "failureThreshold"
    )]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<PostgresClusterProxyPgBouncerContainersReadinessProbeGrpc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterProxyPgBouncerContainersReadinessProbeHttpGet>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initialDelaySeconds"
    )]
    pub initial_delay_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "periodSeconds"
    )]
    pub period_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "successThreshold"
    )]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterProxyPgBouncerContainersReadinessProbeTcpSocket>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationGracePeriodSeconds"
    )]
    pub termination_grace_period_seconds: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutSeconds"
    )]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersReadinessProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersReadinessProbeGrpc {
    pub port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersReadinessProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterProxyPgBouncerContainersReadinessProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersReadinessProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersReadinessProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersSecurityContext {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "allowPrivilegeEscalation"
    )]
    pub allow_privilege_escalation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capabilities: Option<PostgresClusterProxyPgBouncerContainersSecurityContextCapabilities>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub privileged: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "procMount")]
    pub proc_mount: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readOnlyRootFilesystem"
    )]
    pub read_only_root_filesystem: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runAsGroup"
    )]
    pub run_as_group: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runAsNonRoot"
    )]
    pub run_as_non_root: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "runAsUser")]
    pub run_as_user: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "seLinuxOptions"
    )]
    pub se_linux_options:
        Option<PostgresClusterProxyPgBouncerContainersSecurityContextSeLinuxOptions>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "seccompProfile"
    )]
    pub seccomp_profile:
        Option<PostgresClusterProxyPgBouncerContainersSecurityContextSeccompProfile>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "windowsOptions"
    )]
    pub windows_options:
        Option<PostgresClusterProxyPgBouncerContainersSecurityContextWindowsOptions>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersSecurityContextCapabilities {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub drop: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersSecurityContextSeLinuxOptions {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub level: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersSecurityContextSeccompProfile {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localhostProfile"
    )]
    pub localhost_profile: Option<String>,
    #[serde(rename = "type")]
    pub r#type: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersSecurityContextWindowsOptions {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gmsaCredentialSpec"
    )]
    pub gmsa_credential_spec: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gmsaCredentialSpecName"
    )]
    pub gmsa_credential_spec_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "hostProcess"
    )]
    pub host_process: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "runAsUserName"
    )]
    pub run_as_user_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersStartupProbe {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<PostgresClusterProxyPgBouncerContainersStartupProbeExec>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "failureThreshold"
    )]
    pub failure_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grpc: Option<PostgresClusterProxyPgBouncerContainersStartupProbeGrpc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpGet")]
    pub http_get: Option<PostgresClusterProxyPgBouncerContainersStartupProbeHttpGet>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "initialDelaySeconds"
    )]
    pub initial_delay_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "periodSeconds"
    )]
    pub period_seconds: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "successThreshold"
    )]
    pub success_threshold: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tcpSocket")]
    pub tcp_socket: Option<PostgresClusterProxyPgBouncerContainersStartupProbeTcpSocket>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "terminationGracePeriodSeconds"
    )]
    pub termination_grace_period_seconds: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "timeoutSeconds"
    )]
    pub timeout_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersStartupProbeExec {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub command: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersStartupProbeGrpc {
    pub port: i32,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersStartupProbeHttpGet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaders"
    )]
    pub http_headers:
        Option<Vec<PostgresClusterProxyPgBouncerContainersStartupProbeHttpGetHttpHeaders>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    pub port: IntOrString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersStartupProbeHttpGetHttpHeaders {
    pub name: String,
    pub value: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersStartupProbeTcpSocket {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    pub port: IntOrString,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersVolumeDevices {
    #[serde(rename = "devicePath")]
    pub device_path: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerContainersVolumeMounts {
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "mountPropagation"
    )]
    pub mount_propagation: Option<String>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subPathExpr"
    )]
    pub sub_path_expr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerCustomTLSSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterProxyPgBouncerCustomTLSSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerCustomTLSSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PostgresClusterProxyPgBouncerServiceMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<PostgresClusterProxyPgBouncerServiceType>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerServiceMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresClusterProxyPgBouncerServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
    LoadBalancer,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerSidecars {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "pgbouncerConfig"
    )]
    pub pgbouncer_config: Option<PostgresClusterProxyPgBouncerSidecarsPgbouncerConfig>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerSidecarsPgbouncerConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterProxyPgBouncerSidecarsPgbouncerConfigResources>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerSidecarsPgbouncerConfigResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tolerationSeconds"
    )]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerTopologySpreadConstraints {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "labelSelector"
    )]
    pub label_selector: Option<PostgresClusterProxyPgBouncerTopologySpreadConstraintsLabelSelector>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minDomains"
    )]
    pub min_domains: Option<i32>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerTopologySpreadConstraintsLabelSelector {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchExpressions"
    )]
    pub match_expressions: Option<
        Vec<PostgresClusterProxyPgBouncerTopologySpreadConstraintsLabelSelectorMatchExpressions>,
    >,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterProxyPgBouncerTopologySpreadConstraintsLabelSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PostgresClusterServiceMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<PostgresClusterServiceType>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterServiceMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresClusterServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
    LoadBalancer,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStandby {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoName")]
    pub repo_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterface {
    #[serde(rename = "pgAdmin")]
    pub pg_admin: PostgresClusterUserInterfacePgAdmin,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdmin {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub affinity: Option<PostgresClusterUserInterfacePgAdminAffinity>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<PostgresClusterUserInterfacePgAdminConfig>,
    #[serde(rename = "dataVolumeClaimSpec")]
    pub data_volume_claim_spec: PostgresClusterUserInterfacePgAdminDataVolumeClaimSpec,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PostgresClusterUserInterfacePgAdminMetadata>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterUserInterfacePgAdminResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub service: Option<PostgresClusterUserInterfacePgAdminService>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresClusterUserInterfacePgAdminTolerations>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "topologySpreadConstraints"
    )]
    pub topology_spread_constraints:
        Option<Vec<PostgresClusterUserInterfacePgAdminTopologySpreadConstraints>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinity {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "nodeAffinity"
    )]
    pub node_affinity: Option<PostgresClusterUserInterfacePgAdminAffinityNodeAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAffinity"
    )]
    pub pod_affinity: Option<PostgresClusterUserInterfacePgAdminAffinityPodAffinity>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "podAntiAffinity"
    )]
    pub pod_anti_affinity: Option<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinity>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresClusterUserInterfacePgAdminAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresClusterUserInterfacePgAdminAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresClusterUserInterfacePgAdminAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "podAffinityTerm")]
    pub pod_affinity_term: PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespaces: Option<Vec<String>>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfig {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<PostgresClusterUserInterfacePgAdminConfigFiles>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "ldapBindPassword"
    )]
    pub ldap_bind_password: Option<PostgresClusterUserInterfacePgAdminConfigLdapBindPassword>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub settings: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFiles {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<PostgresClusterUserInterfacePgAdminConfigFilesConfigMap>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "downwardAPI"
    )]
    pub downward_api: Option<PostgresClusterUserInterfacePgAdminConfigFilesDownwardAPI>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<PostgresClusterUserInterfacePgAdminConfigFilesSecret>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serviceAccountToken"
    )]
    pub service_account_token:
        Option<PostgresClusterUserInterfacePgAdminConfigFilesServiceAccountToken>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesConfigMap {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterUserInterfacePgAdminConfigFilesConfigMapItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesConfigMapItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesDownwardAPI {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterUserInterfacePgAdminConfigFilesDownwardAPIItems>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesDownwardAPIItems {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<PostgresClusterUserInterfacePgAdminConfigFilesDownwardAPIItemsFieldRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref:
        Option<PostgresClusterUserInterfacePgAdminConfigFilesDownwardAPIItemsResourceFieldRef>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesDownwardAPIItemsFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesDownwardAPIItemsResourceFieldRef {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    pub resource: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesSecret {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<PostgresClusterUserInterfacePgAdminConfigFilesSecretItems>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesSecretItems {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<i32>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigFilesServiceAccountToken {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "expirationSeconds"
    )]
    pub expiration_seconds: Option<i64>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminConfigLdapBindPassword {
    pub key: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminDataVolumeClaimSpec {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessModes"
    )]
    pub access_modes: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSource"
    )]
    pub data_source: Option<PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecDataSource>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "dataSourceRef"
    )]
    pub data_source_ref:
        Option<PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecDataSourceRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecSelector>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageClassName"
    )]
    pub storage_class_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeMode"
    )]
    pub volume_mode: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "volumeName"
    )]
    pub volume_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecDataSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecDataSourceRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecSelector {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchExpressions"
    )]
    pub match_expressions:
        Option<Vec<PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecSelectorMatchExpressions>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminDataVolumeClaimSpecSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminService {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<PostgresClusterUserInterfacePgAdminServiceMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodePort")]
    pub node_port: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<PostgresClusterUserInterfacePgAdminServiceType>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminServiceMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresClusterUserInterfacePgAdminServiceType {
    #[serde(rename = "ClusterIP")]
    ClusterIp,
    NodePort,
    LoadBalancer,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tolerationSeconds"
    )]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminTopologySpreadConstraints {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "labelSelector"
    )]
    pub label_selector:
        Option<PostgresClusterUserInterfacePgAdminTopologySpreadConstraintsLabelSelector>,
    #[serde(rename = "maxSkew")]
    pub max_skew: i32,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minDomains"
    )]
    pub min_domains: Option<i32>,
    #[serde(rename = "topologyKey")]
    pub topology_key: String,
    #[serde(rename = "whenUnsatisfiable")]
    pub when_unsatisfiable: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminTopologySpreadConstraintsLabelSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresClusterUserInterfacePgAdminTopologySpreadConstraintsLabelSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUserInterfacePgAdminTopologySpreadConstraintsLabelSelectorMatchExpressions
{
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUsers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub databases: Option<Vec<String>>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<PostgresClusterUsersPassword>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterUsersPassword {
    #[serde(rename = "type")]
    pub r#type: PostgresClusterUsersPasswordType,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresClusterUsersPasswordType {
    #[serde(rename = "ASCII")]
    Ascii,
    AlphaNumeric,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatus {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<PostgresClusterStatusConditions>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseInitSQL"
    )]
    pub database_init_sql: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "databaseRevision"
    )]
    pub database_revision: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instances: Option<Vec<PostgresClusterStatusInstances>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub monitoring: Option<PostgresClusterStatusMonitoring>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    pub observed_generation: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patroni: Option<PostgresClusterStatusPatroni>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pgbackrest: Option<PostgresClusterStatusPgbackrest>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postgresVersion"
    )]
    pub postgres_version: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proxy: Option<PostgresClusterStatusProxy>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "startupInstance"
    )]
    pub startup_instance: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "startupInstanceSet"
    )]
    pub startup_instance_set: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "userInterface"
    )]
    pub user_interface: Option<PostgresClusterStatusUserInterface>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usersRevision"
    )]
    pub users_revision: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusConditions {
    #[serde(rename = "lastTransitionTime")]
    pub last_transition_time: String,
    pub message: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "observedGeneration"
    )]
    pub observed_generation: Option<i64>,
    pub reason: String,
    pub status: PostgresClusterStatusConditionsStatus,
    #[serde(rename = "type")]
    pub r#type: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresClusterStatusConditionsStatus {
    True,
    False,
    Unknown,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusInstances {
    pub name: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readyReplicas"
    )]
    pub ready_replicas: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "updatedReplicas"
    )]
    pub updated_replicas: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusMonitoring {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "exporterConfiguration"
    )]
    pub exporter_configuration: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusPatroni {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub switchover: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "switchoverTimeline"
    )]
    pub switchover_timeline: Option<i64>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "systemIdentifier"
    )]
    pub system_identifier: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusPgbackrest {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "manualBackup"
    )]
    pub manual_backup: Option<PostgresClusterStatusPgbackrestManualBackup>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "repoHost")]
    pub repo_host: Option<PostgresClusterStatusPgbackrestRepoHost>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repos: Option<Vec<PostgresClusterStatusPgbackrestRepos>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restore: Option<PostgresClusterStatusPgbackrestRestore>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "scheduledBackups"
    )]
    pub scheduled_backups: Option<Vec<PostgresClusterStatusPgbackrestScheduledBackups>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusPgbackrestManualBackup {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "completionTime"
    )]
    pub completion_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failed: Option<i32>,
    pub finished: bool,
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeeded: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusPgbackrestRepoHost {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ready: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusPgbackrestRepos {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bound: Option<bool>,
    pub name: String,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "replicaCreateBackupComplete"
    )]
    pub replica_create_backup_complete: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "repoOptionsHash"
    )]
    pub repo_options_hash: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "stanzaCreated"
    )]
    pub stanza_created: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volume: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusPgbackrestRestore {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "completionTime"
    )]
    pub completion_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failed: Option<i32>,
    pub finished: bool,
    pub id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeeded: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusPgbackrestScheduledBackups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub active: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "completionTime"
    )]
    pub completion_time: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "cronJobName"
    )]
    pub cron_job_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failed: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repo: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "startTime")]
    pub start_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub succeeded: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusProxy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pgBouncer")]
    pub pg_bouncer: Option<PostgresClusterStatusProxyPgBouncer>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusProxyPgBouncer {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "postgresRevision"
    )]
    pub postgres_revision: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "readyReplicas"
    )]
    pub ready_replicas: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusUserInterface {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pgAdmin")]
    pub pg_admin: Option<PostgresClusterStatusUserInterfacePgAdmin>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresClusterStatusUserInterfacePgAdmin {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "usersRevision"
    )]
    pub users_revision: Option<String>,
}
