// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium ingressroutes.traefik.containo.us
// kopium version: 0.14.0

use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
use kube::CustomResource;
use serde::{Deserialize, Serialize};

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(
    group = "traefik.containo.us",
    version = "v1alpha1",
    kind = "IngressRoute",
    plural = "ingressroutes"
)]
#[kube(namespaced)]
#[kube(schema = "disabled")]
pub struct IngressRouteSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "entryPoints")]
    pub entry_points: Option<Vec<String>>,
    pub routes: Vec<IngressRouteRoutes>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<IngressRouteTls>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteRoutes {
    pub kind: IngressRouteRoutesKind,
    #[serde(rename = "match")]
    pub r#match: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub middlewares: Option<Vec<IngressRouteRoutesMiddlewares>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<IngressRouteRoutesServices>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum IngressRouteRoutesKind {
    Rule,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteRoutesMiddlewares {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteRoutesServices {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<IngressRouteRoutesServicesKind>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nativeLB")]
    pub native_lb: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passHostHeader")]
    pub pass_host_header: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<IntOrString>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "responseForwarding"
    )]
    pub response_forwarding: Option<IngressRouteRoutesServicesResponseForwarding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serversTransport")]
    pub servers_transport: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sticky: Option<IngressRouteRoutesServicesSticky>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum IngressRouteRoutesServicesKind {
    Service,
    TraefikService,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteRoutesServicesResponseForwarding {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "flushInterval")]
    pub flush_interval: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteRoutesServicesSticky {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cookie: Option<IngressRouteRoutesServicesStickyCookie>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteRoutesServicesStickyCookie {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "httpOnly")]
    pub http_only: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sameSite")]
    pub same_site: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secure: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certResolver")]
    pub cert_resolver: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domains: Option<Vec<IngressRouteTlsDomains>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub options: Option<IngressRouteTlsOptions>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub store: Option<IngressRouteTlsStore>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteTlsDomains {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub main: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sans: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteTlsOptions {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct IngressRouteTlsStore {
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}
